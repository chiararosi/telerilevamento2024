library(terra) 
#il pacchetto terra permette di manipolare dati geografici (spaziali) nella forma di "raster" e "vettori".
# I dati Raster dividono lo spazio in griglie regolari di celle e sono comunemente usate per rappresentare fenomeni spazialmente continui es. le condizioni ambientali.
#Le immagini satellitari hanno anche loro questa struttura di dati, e in questo contesto le griglie di celle sono spesso riferiti come pixels.
#I vettori invece dei dati spaziali (punti, linee, poligoni) sono spesso usati per rappresentare entità spaziali discrete, come le strade e paesi.
#In questo progetto si lavorerà su dati di tipologia SpatRaster.
library(imageRy) 
#il pacchetto imageRy permette di manipolare e analizzare immagini raster, particolarmente utili per immagini satellitari, utile perché si può usare insieme al pacchetto terra
library(viridisLite)
library(viridis)
# questi due pacchetti forniscono una palette di colori che possono essere visti facilmente anche per i daltonici, ottimizzando così la visualizzazione delle immagini
library(ggplot2)
# il pacchetto ggplot2 permette di creare grafici personalizzati e complessi, utile per confrontare le variazioni temporali
library(patchwork) 
#Del pacchetto terra la funzione area viene mascherata da quella del pacchetto patchwork
# il pacchetto patchwork è utile per disporre i grafici creati tramite ggplot2, organizza i grafici creando layout precisi, permette la composizione di più grafici e allo stesso tempo la loro analisi
library(ggfortify)
#semplifica la visualizzazione di analisi multivariate (es. Analisi delle Componenti Principali = PCA) in relazione ai grafici di ggplot2
library(factoextra)
#questo pacchetto semplifica la visualizzazione e l'interpretazione delle analisi multivariate


#list.files() è una funzione di R che mi permette di elencare tutti i files presenti nella directory che io ho specificato, quindi come output ci saranno tutti i nomi dei file presenti nella cartella
#imposto ora la directory su cui lavorerò, dove R prenderà i files, la cartella del mio computer con la funzione setwd()

#Caricare le bande multispettrali del 2020
#Anno 2020 

list.files("C:/Users/kiko9/Downloads/esametele/2020")
setwd("C:/Users/kiko9/Downloads/esametele/2020")
#la funzione rast() è una funzione del pacchetto terra e serve a caricare un oggetto raster su R
# creo un oggetto Banda02_2020 attraverso l'assegnazione <- 
#mi importo la banda 2 dell'immagine Sentinel-2, la banda 2 di Sentinel corrisponde alla banda del blu, con una lunghezza d'onda: 490 nm.
#metto le virgolette perché sono presenti nel nome completo dell'immagine
#Gli oggetti raster rappresentano dati spaziali organizzati in una griglia regolare di celle (pixel)

Banda02_2020 <- rast ("2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_B02_(Raw).tiff") 

# TIFF= Tagged Image File Format, è un formato di file utilizzato per immagini raster, è in grado immagazzinare dati geospaziali e può supportare immagini multispettrali

Banda03_2020 <- rast ("2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_B03_(Raw).tiff")
#Carico attraverso la funzione rast() la Banda numero 3 del satellite Sentinel-2 che corrisponde alla banda del verde, creo un oggetto Banda03_2020 attraverso l'assegnazione <-
#La banda del Verde ha una lunghezza d'onda di 560 nm
Banda04_2020 <- rast ("2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_B04_(Raw).tiff")
#Carico la Banda numero 4 che rappresenterebbe la banda del rosso. Lunghezza d'onda: 665 nm.
Banda08_2020 <- rast ("2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_B08_(Raw).tiff")
#La banda numero 8 è il NIR= Near InfraRed, Vicino Infrarosso. Lunghezza d'onda: 842 nm.
Banda8A_2020 <- rast ("2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_B8A_(Raw).tiff")
#La Banda 8A rappresenta il Narrow NIR, è una parte specifica dell'infrarosso vicino, ha una lunghezza d'onda centrata a 865 nm; offre maggiori dettagli rispetto alla banda del NIR
Banda12_2020 <- rast ("2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_B12_(Raw).tiff")
#La Banda 12 rappresenta la banda SWIR= Short Wave Infrared, è un sottoinsieme della banda dell'infrarosso, molto utile perché differenzia bene l'acqua dalla vegetazione, 

#Questa operazione la faccio per tutti gli anni che ho preso in considerazione

# Anno 2021
list.files("C:/Users/kiko9/Downloads/esametele/2021")
setwd("C:/Users/kiko9/Downloads/esametele/2021")
Banda02_2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_B02_(Raw).tiff")
Banda03_2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_B03_(Raw).tiff")
Banda04_2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_B04_(Raw).tiff")
Banda08_2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_B08_(Raw).tiff")
Banda8A_2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_B8A_(Raw).tiff")
Banda12_2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_B12_(Raw).tiff")

#Anno 2022
list.files("C:/Users/kiko9/Downloads/esametele/2022")
setwd("C:/Users/kiko9/Downloads/esametele/2022")
Banda02_2022 <- rast ("2022-05-28-00_00_2022-05-28-23_59_Sentinel-2_L1C_B02_(Raw).tiff")
Banda03_2022 <- rast ("2022-05-28-00_00_2022-05-28-23_59_Sentinel-2_L1C_B03_(Raw).tiff")
Banda04_2022 <- rast ("2022-05-28-00_00_2022-05-28-23_59_Sentinel-2_L1C_B04_(Raw).tiff")
Banda08_2022 <- rast ("2022-05-28-00_00_2022-05-28-23_59_Sentinel-2_L1C_B08_(Raw).tiff")
Banda8A_2022 <- rast ("2022-05-28-00_00_2022-05-28-23_59_Sentinel-2_L1C_B8A_(Raw).tiff")
Banda12_2022 <- rast ("2022-05-28-00_00_2022-05-28-23_59_Sentinel-2_L1C_B12_(Raw).tiff")

#Anno 2023
list.files("C:/Users/kiko9/Downloads/esametele/2023")
setwd("C:/Users/kiko9/Downloads/esametele/2023")
Banda02_2023 <- rast ("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_B02_(Raw).tiff")
Banda03_2023 <- rast ("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_B03_(Raw).tiff")
Banda04_2023 <- rast ("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_B04_(Raw).tiff")
Banda08_2023 <- rast ("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_B08_(Raw).tiff")
Banda8A_2023 <- rast ("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_B8A_(Raw).tiff")
Banda12_2023 <- rast ("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_B12_(Raw).tiff")

#Anno 2024
list.files("C:/Users/kiko9/Downloads/esametele/2024")
setwd("C:/Users/kiko9/Downloads/esametele/2024")
Banda02_2024 <- rast ("2024-05-24-00_00_2024-05-24-23_59_Sentinel-2_L1C_B02_(Raw).tiff")
Banda03_2024 <- rast ("2024-05-24-00_00_2024-05-24-23_59_Sentinel-2_L1C_B03_(Raw).tiff")
Banda04_2024 <- rast ("2024-05-24-00_00_2024-05-24-23_59_Sentinel-2_L1C_B04_(Raw).tiff")
Banda08_2024 <- rast ("2024-05-24-00_00_2024-05-24-23_59_Sentinel-2_L1C_B08_(Raw).tiff")
Banda8A_2024 <- rast ("2024-05-24-00_00_2024-05-24-23_59_Sentinel-2_L1C_B8A_(Raw).tiff")
Banda12_2024 <- rast ("2024-05-24-00_00_2024-05-24-23_59_Sentinel-2_L1C_B12_(Raw).tiff")


# Calcolo degli indici spettrali

#Partendo dall'anno 2020
#NDWI= Normalize Difference Water Index; Indice per il monitoraggio dell'acqua, evidenzia la presenza dell'acqua sulla superficie terrestre
setwd("C:/Users/kiko9/Downloads/esametele/2020")
list.files("C:/Users/kiko9/Downloads/esametele/2020")
#importo l'immagine di Sentinel 2 che rappresenta NDWI attraverso la funzione rast() di terra
#carico l'immagine a colori naturali come oggetto raster
#Questo oggetto TRUECOL2020 lo creo tramite l'assegnazione <-; esso sarà un oggetto di classe SpatRater, multispettrale
#SpatRast è il formato raster usato da terra
#la prima banda è il rosso=Red, la seconda rappresenta il verde = Green; la terza è il Blu; In Sentinel-2, le bande RGB sono 4, 3, 2.
TRUECOL2020 <- rast("2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_True_color.tiff")
plot(TRUECOL2020)
#visualizzo l'immagine plottandola tramite la funzione di R plot() usata nel pacchetto terra che mi permette di visualizzare le immagini raster

NDWI_2020 <- rast( "2020-05-25-00_00_2020-05-25-23_59_Sentinel-2_L1C_NDWI.tiff")
#Creo un nuovo oggetto che rappresenta l'indice NDWI del territorio nel 2020, attraverso la funzione rast() e con assegnazione <-
#Avendo scaricato l'immagine satellitare di Sentinel-2 che rappresenta proprio l'indice Normalize Difference Water Index
# Questo indice evidenzia la presenza di acqua sulla superficie terrestre
plot(NDWI_2020)
#per calcolare l'indice NDWI si usa la banda del Verde e dell'Infrarosso vicino
indexNDWI_2020 <- (Banda03_2020 - Banda08_2020) / (Banda03_2020 + Banda08_2020)
summary(indexNDWI_2020)

#questo indice identifica le aree allagate e in generale la presenza di corpi idrici
#Solo graficamente possiamo vedere che nel 2020 non erano presenti aree allagate nel territorio
#Adesso si può confrontare l'immagine True Color con l'immagine NDWI dopo averle plottate attraverso la funzione par() creando un multiframe
par(mfrow=c(1,2))
#attraverso la funzione par() metto in fila le due immagini, mfrow= mi permette di specificare il numero di righe e di colonne che imposterò 
# c() mi permette di creare un vettore, per cui di concatenare degli elementi insieme, in questo caso combinerò le righe con le colonne
plot(TRUECOL2020)
plot(NDWI_2020)
dev.off()
#Se i valori di NDWI sono elevati indicano la presenza di acqua


#calcolando l'indice NDVI= Normalize Difference Vegetation Index
#NDVI è l'indice normalizzato, per cui non ha alcun rapporto con la risoluzione radiometrica
# Misura la salute della vegetazione sulla base della riflettanza del rosso e del NIR
#per essere misurato quest'indice utilizza la banda del NIR e del Rosso
NDVI_2020 <- (Banda08_2020 - Banda04_2020) / (Banda08_2020 + Banda04_2020)
summary(NDVI_2020)
#i valori soglia 0.2 o 0.3 rappresenta una copertura vegetale molto bassa, quasi suolo nudo
#pongo il valore soglia > 0.3, così che posso analizzare se è presente vegetazione sana o meno ed è utile quando si vuole fare dei confronti temporali
vegetazione_2020 <- NDVI_2020 > 0.3
#posso plottare questo oggetto, per vedere quali sono le aree con una vegetazione superiore al valore soglia di 0.3
plot(vegetazione_2020, main = "Vegetazione 2020")
# mi da due valori: False e True, mi classifica quindi la porzione in cui c'è vegetazione (NDVI con valore maggiore di 0.3)= True e l'altra dove non c'è vegetazione= False (valori minori di 0.2)

#CLUSTERIZZARE L'IMMAGINE DIVIDENDOLA IN CLASSI
#classifico l'immagine NDWI in quattro classi
#L'indice NDWI viene usato per monitorare i cambiamenti relativi al contenuto di acqua presente nel territorio
#Index values greater than 0.5 usually correspond to water bodies. Vegetation usually corresponds to much smaller values and built-up areas to values between zero and 0.2.
#NIR-SWIR highlighting differences in water content of leaves, and GREEN-NIR highlighting differences in water content of water bodies, we have decided to separate the indices on our repository as NDMI using NIR-SWIR, and NDWI using GREEN-NIR.
#lo suddivido in 4 classi: area altamente umida, area mediamente umida, area poco umida, area secca
class_col <- c("darkturquoise", "darkolivegreen", "darkorchid3", "chocolate4")
ClassificationNDWI_2020 <- im.classify( NDWI_2020, 4, seed=TRUE)
#la funzione im.classify() è del pacchetto imageRy, mi permette di classificare le immagini
#classifica tutti i pixel di una immagine raster
#all'interno di im.classify() il primo argomento è proprio l'immagine raster che si vuole andare a classificare, dopodiché 4 sono le classi
# seed=TRUE è per garantire che i risultati siano sempre gli stessi e quindi riproducibili 
# Ora si può visualizzare il raster classificato
plot( ClassificationNDWI_2020, col = class_col, main = "Classificazione 2020 NDWI")
#oppure con la palette di colori viridis
plot( ClassificationNDWI_2020, col = viridis(4), main = "Classificazione 2020 NDWI")
# 1=area molto umida, con NDWI > 0.3; 2= area mediamente umida, con  0<=NDWI>= 0.3; 3= area poco umida con -0.2 <= NDWI=> 0; 4= area secca con NDWI< -0.2
#adesso vogliamo calcolare la frequenza di queste classi, le calcolo prendendo in considerazione il numero di pixel presente in ogni classe
FreqNDWI_2020 <- freq( ClassificationNDWI_2020)
FreqNDWI_2020
# per la classe 1= 344000; classe 2= 323342; classe 3= 471673; classe 4= 208485
#la classe maggiormente dominante è la classe 3, per cui le aree poco umide, per il 2020
#adesso ci si può calcolare la proporzione, che non è altro che il numero di pixel della classe fratto il totale
#calcolo il totale dei pixel
tot2020 <- ncell(NDWI_2020)
tot2020
#il numero di celle del raster NDWI_2020 sono 1347500
#la proporzione è la frequenza diviso il totale
prop2020 = FreqNDWI_2020 / tot2020
prop2020
#area altamente umida= 26%; area mediamente umida = 24%; area poco umida= 35%; area secca= 15%
dev.off()



#Analisi 2021
#richiamo la directory per l'anno 2021
setwd("C:/Users/kiko9/Downloads/esametele/2021")
#rivedo i files che sono presenti al suo interno
list.files("C:/Users/kiko9/Downloads/esametele/2021")
#prelevo dalla lista il raster dell'immagine True Color e NDWI
TRUECOL2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_True_color.tiff")
NDWI_2021 <- rast("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_NDWI.tiff")
#creo un multiframe con queste due immagini raster spaziali
par(mfrow=c(1,2))
plot(TRUECOL2021)
plot(NDWI_2021)
dev.off()
# calcolo l'indice NDVI del 2020
NDVI_2021 <- (Banda08_2021 - Banda04_2021) / (Banda08_2021 + Banda04_2021)
summary(NDVI_2021)
vegetazione_2021 <- NDVI_2021 > 0.3
plot (vegetazione_2021, main = "Indice di Vegetazione 2021")
#si presentano due classi True e False, in True è presente la vegetazione, in False è presente l'assenza di vegetazione o perlomeno con un indice NDVI < 0.3
#posso classificare ora l'immagine NDWI
#1° classe: area molto umida, 2° classe: area umida; 3° classe: area poco umida; 4° classe: area secca
#creo il vettore con i colori che utilizzerò nella immagine
class_col <- c("darkturquoise", "darkolivegreen", "darkorchid3", "chocolate4")
ClassificationNDWI_2021 <- im.classify (NDWI_2021, 4, seed= TRUE)
plot( ClassificationNDWI_2021, col = class_col, main = "Classificazione Aree Umide 2021")



setwd("C:/Users/kiko9/Downloads/esametele/2021")
#rivedo i files che sono presenti al suo interno
list.files("C:/Users/kiko9/Downloads/esametele/2021")
#prelevo dalla lista il raster dell'immagine True Color e NDWI
TRUECOL2021 <- rast ("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_True_color.tiff")
SWIR_2021 <- rast("2021-05-20-00_00_2021-05-20-23_59_Sentinel-2_L1C_SWIR.tiff")
#creo un multiframe con queste due immagini raster spaziali
par(mfrow=c(1,2))
plot(TRUECOL2021)
plot(SWIR_2021)
dev.off()
# calcolo l'indice NDVI del 2020
NDVI_2021 <- (Banda08_2021 - Banda04_2021) / (Banda08_2021 + Banda04_2021)
summary(NDVI_2021)
vegetazione_2021 <- NDVI_2021 > 0.3
plot (vegetazione_2021, main = "Indice di Vegetazione 2021")
#si presentano due classi True e False, in True è presente la vegetazione, in False è presente l'assenza di vegetazione o perlomeno con un indice NDVI < 0.3
#posso classificare ora l'immagine NDWI
#1° classe: area molto umida, 2° classe: area umida; 3° classe: area poco umida; 4° classe: area secca
#creo il vettore con i colori che utilizzerò nella immagine
class_col <- c("darkturquoise", "darkolivegreen", "darkorchid3", "chocolate4")
ClassificationSWIR_2021 <- im.classify (SWIR_2021, 4, seed= TRUE)
plot( ClassificationSWIR_2021, col = class_col, main = "Classificazione Aree Umide 2021")







#
#Calcolo ora le frequenze delle varie aree
FreqNDWI_2021 <- freq (ClassificationNDWI_2021)
FreqNDWI_2021
# per la 1° classe= 310892 pixels, 2° classe = 414370; 3° classe = 303857; 4° classe = 318381
#Calcolo ora le proporzioni, prima trovando il totale
tot2021 <- ncell(NDWI_2021)
tot2021
#il totale dei pixel sono 1347500
prop2021 = FreqNDWI_2021 / tot2021
prop2021
# la 1° classe è il 23%; 2° classe rappresenta il 31%; la 3° classe è il 22%; la 4° classe è il 24%

#Analisi del 2022

#Analisi del 2023
list.files("C:/Users/kiko9/Downloads/esametele/2023")
setwd("C:/Users/kiko9/Downloads/esametele/2023")
TRUECOL2023 <- rast("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_True_color.tiff")
NDWI_2023 <- rast("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_NDWI.tiff")
par(mfrow=c(1,2))
plot(TRUECOL2023)
plot(NDWI_2023)
dev.off()
# calcolo l'indice NDVI del 2023
NDVI_2023 <- (Banda08_2023 - Banda04_2023) / (Banda08_2023 + Banda04_2023)
summary(NDVI_2023)
vegetazione_2023 <- NDVI_2023 > 0.3
plot (vegetazione_2023, main = "Indice di Vegetazione 2023")
#si presentano due classi True e False, in True è presente la vegetazione, in False è presente l'assenza di vegetazione o perlomeno con un indice NDVI < 0.3
#posso classificare ora l'immagine NDWI
#1° classe: area molto umida, 2° classe: area umida; 3° classe: area poco umida; 4° classe: area secca
#creo il vettore con i colori che utilizzerò nella immagine
class_col <- c("darkturquoise", "darkolivegreen", "darkorchid3", "chocolate4")
ClassificationNDWI_2023 <- im.classify (NDWI_2023, 4, seed= TRUE)
plot( ClassificationNDWI_2023, col = class_col, main = "Classificazione Aree Umide 2023")
#              la 3° classe rappresenta l'ACQUA, area molto umida
#Calcolo ora le frequenze delle varie aree
FreqNDWI_2023 <- freq (ClassificationNDWI_2023)
FreqNDWI_2021
# per la 1° classe= 310892 pixels, 2° classe = 414370; 3° classe = 303857; 4° classe = 318381
#Calcolo ora le proporzioni, prima trovando il totale
tot2021 <- ncell(NDWI_2021)
tot2021
#il totale dei pixel sono 1347500
prop2021 = FreqNDWI_2021 / tot2021
prop2021
# la 1° classe è il 23%; 2° classe rappresenta il 31%; la 3° classe è il 22%; la 4° classe è il 24%










list.files("C:/Users/kiko9/Downloads/esametele/2023")
setwd("C:/Users/kiko9/Downloads/esametele/2023")
TRUECOL2023 <- rast("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_True_color.tiff")
SWIR_2023 <- rast("2023-05-23-00_00_2023-05-23-23_59_Sentinel-2_L1C_SWIR.tiff")
par(mfrow=c(1,2))
plot(TRUECOL2023)
plot(SWIR_2023)
dev.off()
# calcolo l'indice NDVI del 2023
NDVI_2023 <- (Banda08_2023 - Banda04_2023) / (Banda08_2023 + Banda04_2023)
summary(NDVI_2023)
vegetazione_2023 <- NDVI_2023 > 0.3
plot (vegetazione_2023, main = "Indice di Vegetazione 2023")
#si presentano due classi True e False, in True è presente la vegetazione, in False è presente l'assenza di vegetazione o perlomeno con un indice NDVI < 0.3
#posso classificare ora l'immagine NDWI
#1° classe: area molto umida, 2° classe: area umida; 3° classe: area poco umida; 4° classe: area secca
#creo il vettore con i colori che utilizzerò nella immagine
class_col <- c("darkturquoise", "darkolivegreen", "darkorchid3", "chocolate4")
ClassificationSWIR_2023 <- im.classify (SWIR_2023, 4, seed= TRUE)
plot( ClassificationSWIR_2023, col = class_col, main = "Classificazione Aree Umide 2023")





#              la 3° classe rappresenta l'ACQUA, area molto umida
#Calcolo ora le frequenze delle varie aree
FreqNDWI_2023 <- freq (ClassificationNDWI_2023)
FreqNDWI_2021
# per la 1° classe= 310892 pixels, 2° classe = 414370; 3° classe = 303857; 4° classe = 318381
#Calcolo ora le proporzioni, prima trovando il totale
tot2021 <- ncell(NDWI_2021)
tot2021
#il totale dei pixel sono 1347500
prop2021 = FreqNDWI_2021 / tot2021
prop2021
# la 1° classe è il 23%; 2° classe rappresenta il 31%; la 3° classe è il 22%; la 4° classe è il 24%







